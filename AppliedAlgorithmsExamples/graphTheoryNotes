//10/23/18
//minimal spanning tree
//jungle roads hint
/*
  Brief Hi-Q Hint:
Test case E was the slowest and removed!
There's no letter O, skip over while still numbering
Output needs to show the letters, convert integers back into letters
*/

parent[]               value[]
Parent[A] = nil        value[A] = inf
Parent[B] = nil        value[B] = inf
Parent[C] = nil        value[C] = inf
Parent[D] = nil        value[D] = inf
Parent[E] = nil        value[E] = inf
Parent[F] = nil        value[F] = inf


v{}                   T{}
A
B
C
D
E
F


root = A    (This changes value[A] to 0)
selected

/*
using prim's algorithm is very similar to dikstra's shortest path algorithm
*/






//Building the adjacency matrix
2D array
where array[A][B] is the path from A to B, value stored here is the line weight
intialize all of them to infinity first
read in values
infinity is a keyword that can be used to represent infinity in the matrix
you could also use max int (int max) to represent infinity


linked list is more efficient if its a sparse graph


/*
  Dikstra's Algorithm

  Single Source Algorithm
    There's one place where you want a shortest path from start node to every other node
DO NOT use negative weights in Dikstra's algorithm

erg = smallest unit of work
an erg is approx. the amount of work it takes for a fly to do one pushup
*/

very similar to prim's

V = {A,B,C,D,E,F}  T = {}

Start = A

Selected =

Parent[]                     Distance[]
